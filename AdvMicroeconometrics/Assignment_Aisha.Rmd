---
title: "Adv. Microeconometrics Computer Assignment"
author: "A. Schmidt"
date: "11/19/2020"
output:
  pdf_document: default
bibliography: references.bib
---



```{r, message = FALSE, warning = FALSE, echo = FALSE}
# Verify if a package is already installed, if not, download and install before loading. 
chooseCRANmirror(graphics = FALSE, ind = 10)
if (!require("pacman")) install.packages("pacman")
pacman::p_load(ggplot2, MASS, knitr)
```

```{r, message = FALSE, warning = FALSE, echo = FALSE}
# Prevents code from getting out of the page
## Works with almost everything except urls and strings.
opts_chunk$set(tidy.opts=list(width.cutoff=50),tidy=TRUE)
```

# 1 - Size distortions

Simulate data from the following model:

\begin{align*}
  Y &= X \beta + \varepsilon \\
  X &= Z\Pi + V
\end{align*}
where:
* $Y$ and $X$ are $n \times 1$ vectors which contain the endogenous variables;
* $Z$ is a $n \times k$ matrix of instruments;
* $\varepsilon$ and $V$ are $n \times 1$ vectors that contain disturbances.
* The different rows of $\left(\varepsilon\ \vdots\ V\right)$, are independently normally distributed, i.e., 

\begin{align*}
  \begin{pmatrix}
    \varepsilon_i \\
    V_i
  \end{pmatrix} \sim \mathcal{N}(0, \Sigma), \qquad 
  \Sigma =
  \begin{pmatrix}
  1 & \vdots & \rho \\
  \rho & & 1
  \end{pmatrix}
\end{align*}
* $n=100$, $k=10$, $\Pi = a \times e_{10}$ with $e_{10} \in \mathbb{R}^{10}$ whose first element is $1$ and the remaining are equal to zero.
* All elements from $Z$ are independently distributed and follows a standard normal distribution.
* $a \in \{0.3,.0.25, 0.2, 0.15, 0.1, 0.05, 0 \}$
* $\rho \in \{0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 0.95 \}$

```{r, echo = FALSE, warning = FALSE}
  # This block is a static block that is kept through all 5000 simulations


  # Preparing data
  set.seed(6969)

  # Magic numbers

  dn    <- 100
  dk    <- 10
  va    <- matrix(c(0.3, 0.25, 0.2, 0.15, 0.1, 0.05, 0), nrow = 7, ncol = 1)
  vrho  <- c(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 0.95)
  dbeta <- 1

  
  ## INITIALIZATION ##
  # Generate the Z matrix
  mZ   = matrix(rep(0, dn*dk), nrow = dn, ncol = dk)
  
  for (j in 1:ncol(mZ)){
    mZ[,j] <- rnorm(nrow(mZ), mean = 0, sd = 1)
  }

  # Building a matrix with all Pi
  ve10 <- matrix(c(1, rep(0, dk-1)), nrow=10, ncol = 1)
  mPi  <- t(va %*% t(ve10))

```


```{r, echo = FALSE, warning = FALSE}
# This block simulates the model

fsimul <- function(dn, va, vrho, dBeta, mPi){
  mEV <- array(rep(0, dn*2*length(vrho)), dim = c(dn, 2, length(vrho)))
  
  # Builds the errors sampling from the multivariate normal distribution
  for (i in 1:length(vrho)){
    Sigma   <- matrix(c(1,vrho[i],vrho[i],1),2,2)
    for (j in 1:dn){
      pair    <- mvrnorm(n = 1, rep(0, 2), Sigma)
      mEV[j,,i] <- pair
    }
  }
  
  # Builds X
  lX = list(1,2,3,4,5,6,7,8,9,10)
  
  for(i in 1:length(lX)){
    lX[[i]] <- matrix(rep(0, dn*length(va)), nrow = dn, ncol = length(va))
  }
  
  
  for (j in 1:length(vrho)){
    for (i in 1:length(va)){
      lX[[j]][,i] = mZ %*% mPi[,i] + mEV[,2,j]
    }
  }
  
  # Builds Y
  lY = list(1,2,3,4,5,6,7,8,9,10)
  
  for(i in 1:length(lX)){
    lY[[i]] <- matrix(rep(0, dn*length(va)), nrow = dn, ncol = length(va))
  }
  
  for (j in 1:length(vrho)){
    for (i in 1:length(va)){
      lY[[j]][,i] = lX[[j]][,i] * dbeta + mEV[,1,j]
    }
  }
  
  return(lY, lX, mEV)
}
  
```


## Item 1

_For each value of $\alpha$ make a figure of the rejection frequency as a function of $\rho$ when testing $H_0: \beta = 0$ with $95\%$ significance using the $2SLS$ $t$-statistic (so five figures which show the rejection frequency as a function of $\alpha$).

```{r, echo = FALSE, warning = FALSE}
  # First, estimate using 2SLS
  
  ## First stage
  vPihat = list(1,2,3,4,5,6,7,8,9,10)
  
  for(i in 1:length(lX)){
    vPihat[[i]] <- 0*mPi
  }

  
  lXhat = list(1,2,3,4,5,6,7,8,9,10)
  
  for (i in 1:length(lX)){
    lXhat[[i]] <- 0 * lX[[i]]
  }
  

  for (j in 1:length(vrho)){
    for (i in 1:length(va)){
      first_stage     <- lm(lX[[i]][,i] ~ mZ - 1)
      vPihat[[j]][,i] <- first_stage$coefficients
      lXhat[[j]][,i]  <- first_stage$fitted.values
    }
  }
  
  # Second stage
  

```


